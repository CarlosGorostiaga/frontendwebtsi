---
const stats = [
  { value: 30,  label: "Años de Experiencia"},
  { value: 3,   label: "Países" },
  { value: 500, label: "Proyectos", suffix: "+" },
  { value: 100, label: "Satisfacción", suffix: "%" },
];
---

<section class="py-16 bg-white">
  <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
    <div class="grid grid-cols-2 lg:grid-cols-4 gap-8 text-center">
      {stats.map((it, index) => (
        <div class="p-6 transform hover:scale-105 transition-transform duration-200">
          <div 
            class="text-4xl lg:text-5xl font-bold mb-2 text-orange-500 counter" 
            data-target={it.value.toString()}
            data-suffix={it.suffix || ""}
            id={`counter-${index}`}
          >
            0{it.suffix || ""}
          </div>
          <div class="text-gray-600 font-medium">{it.label}</div>
        </div>
      ))}
    </div>
  </div>
</section>

<script>
  document.addEventListener("DOMContentLoaded", () => {
    const counters = document.querySelectorAll<HTMLDivElement>(".counter");

    const animateCounter = (counter: HTMLDivElement) => {
      const targetAttr = counter.getAttribute("data-target");
      const suffix = counter.getAttribute("data-suffix") || "";
      if (!targetAttr) return;

      const target = parseInt(targetAttr, 10);
      const duration = 1500; // 1.5 segundos
      const start = performance.now();

      const animate = (time: number) => {
        const progress = Math.min((time - start) / duration, 1);
        const eased = 1 - Math.pow(1 - progress, 3); // easeOutCubic
        const value = Math.floor(eased * target);

        counter.textContent = value.toString() + suffix;

        if (progress < 1) {
          requestAnimationFrame(animate);
        }
      };

      requestAnimationFrame(animate);
    };

    // Solo arrancar cuando entren en pantalla
    const observer = new IntersectionObserver((entries, obs) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          animateCounter(entry.target as HTMLDivElement);
          obs.unobserve(entry.target); // solo una vez
        }
      });
    }, { threshold: 0.3 });

    counters.forEach(counter => observer.observe(counter));
  });
</script>
